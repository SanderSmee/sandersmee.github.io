<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thoughts.toString();</title>
  
  <subtitle>My thoughts.toString(); For you to explore</subtitle>
  <link href="http://thoughts.tostring.blog/atom.xml" rel="self"/>
  
  <link href="http://thoughts.tostring.blog/"/>
  <updated>2022-02-13T16:33:59.908Z</updated>
  <id>http://thoughts.tostring.blog/</id>
  
  <author>
    <name>Sander Smeman</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Override asciidoctor gradle plugin versions</title>
    <link href="http://thoughts.tostring.blog/override-asciidoctor-gradle-versions/"/>
    <id>http://thoughts.tostring.blog/override-asciidoctor-gradle-versions/</id>
    <published>2022-02-13T19:00:00.000Z</published>
    <updated>2022-02-13T16:33:59.908Z</updated>
    
    
    <summary type="html">&lt;p&gt;As development team we decided to write our documentation with Asciidoc.
As other parts in our landscape use gradle as the build tool, thus we opted for the asciidoctor-gradle-plugin to generate the documentation.
The documents have embedded plantuml diagrams describing the architecture, but to our surprise the toolchain did not render them correctly.
Apparently the diagrams use features of plantuml that are not supported in the version provided by default by the toolchain.&lt;/p&gt;
&lt;p&gt;We found out we had to update to later versions of asciidoctorj-diagram and plantuml.
The version of asciidoctor-gradle-plugin (3.3.2) is now about a year old (from February 2021) and probably its dependencies also.
Unfortunately it&amp;#8217;s rather hard to find which versions are used by the asciidoctor-gradle plugin and how to update to newer versions.&lt;/p&gt;</summary>
    
    
    
    <category term="Howto" scheme="http://thoughts.tostring.blog/category/Howto/"/>
    
    
    <category term="documentation" scheme="http://thoughts.tostring.blog/tags/documentation/"/>
    
    <category term="plantuml" scheme="http://thoughts.tostring.blog/tags/plantuml/"/>
    
    <category term="gradle" scheme="http://thoughts.tostring.blog/tags/gradle/"/>
    
    <category term="asciidoctor" scheme="http://thoughts.tostring.blog/tags/asciidoctor/"/>
    
  </entry>
  
  <entry>
    <title>Custom, optional attributes in spring-restdocs</title>
    <link href="http://thoughts.tostring.blog/custom-attributes-in-spring-restdocs/"/>
    <id>http://thoughts.tostring.blog/custom-attributes-in-spring-restdocs/</id>
    <published>2019-03-20T16:09:20.000Z</published>
    <updated>2020-09-01T20:36:49.225Z</updated>
    
    
    <summary type="html">&lt;p&gt;Documenting spring restcontrollers with spring-restdocs is a sure way to get great documentation.
It allows one to document API endpoints based on examples used in a test, and document specific fields in a response.
It&amp;#8217;s even possible to document additional attributes of a field in a JSON response.&lt;/p&gt;</summary>
    
    
    
    <category term="Howto" scheme="http://thoughts.tostring.blog/category/Howto/"/>
    
    
    <category term="documentation" scheme="http://thoughts.tostring.blog/tags/documentation/"/>
    
    <category term="spring-restdocs" scheme="http://thoughts.tostring.blog/tags/spring-restdocs/"/>
    
    <category term="asciidoc" scheme="http://thoughts.tostring.blog/tags/asciidoc/"/>
    
  </entry>
  
  <entry>
    <title>Testable architecture</title>
    <link href="http://thoughts.tostring.blog/testable-architecture/"/>
    <id>http://thoughts.tostring.blog/testable-architecture/</id>
    <published>2019-02-06T23:00:00.000Z</published>
    <updated>2020-09-01T20:36:49.224Z</updated>
    
    
    <summary type="html">&lt;p&gt;My coworker points me to the presentation of Aslak Helles√∏y, &lt;a href=&quot;https://www.youtube.com/watch?v=PE_1nh0DdbY&quot;&gt;Sub-second acceptance tests&lt;/a&gt;.
As we&amp;#8217;re struggling with long running and brittle acceptance tests, that provoking title triggers my interest, and I start watching the recording&amp;#8230;&amp;#8203;&lt;/p&gt;</summary>
    
    
    
    <category term="Architecture" scheme="http://thoughts.tostring.blog/category/Architecture/"/>
    
    
    <category term="hexagonal" scheme="http://thoughts.tostring.blog/tags/hexagonal/"/>
    
    <category term="test" scheme="http://thoughts.tostring.blog/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Reduce the code to noise ratio of maven POMs</title>
    <link href="http://thoughts.tostring.blog/reduce-code-noise-ratio-maven-poms/"/>
    <id>http://thoughts.tostring.blog/reduce-code-noise-ratio-maven-poms/</id>
    <published>2018-10-28T23:00:00.000Z</published>
    <updated>2020-09-01T20:36:49.223Z</updated>
    
    
    <summary type="html">&lt;p&gt;I really like maven for the structured way it provides for defining and building a project.
But sometimes I wish for a less verbose notation than the XML of the Project Object Model (POM).
For example, gradles dependency notation is far shorter than mavens dependency declaration.&lt;/p&gt;</summary>
    
    
    
    <category term="Programming" scheme="http://thoughts.tostring.blog/category/Programming/"/>
    
    
    <category term="maven" scheme="http://thoughts.tostring.blog/tags/maven/"/>
    
    <category term="yaml" scheme="http://thoughts.tostring.blog/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Easily build your own tech radar</title>
    <link href="http://thoughts.tostring.blog/easily-build-your-own-tech-radar/"/>
    <id>http://thoughts.tostring.blog/easily-build-your-own-tech-radar/</id>
    <published>2018-10-14T22:00:00.000Z</published>
    <updated>2020-09-01T20:36:49.223Z</updated>
    
    
    <summary type="html">&lt;p&gt;The &lt;a href=&quot;https://www.thoughtworks.com/radar&quot;&gt;Thoughtworks Technology Radar&lt;/a&gt; is well known for showing technology trends and choices.
For my project I wanted to have the same thing, not use the hosted public version from Thoughtworks, but a selfhosted option.
Therefore I choose to base it on the Zalando opensource tech radar, and create a way to use a CSV file as input so updating would be an easy thing to do.&lt;/p&gt;</summary>
    
    
    
    <category term="Documentation" scheme="http://thoughts.tostring.blog/category/Documentation/"/>
    
    
    <category term="architecture" scheme="http://thoughts.tostring.blog/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Plantuml labels like swagger-ui</title>
    <link href="http://thoughts.tostring.blog/plantuml-swagger/"/>
    <id>http://thoughts.tostring.blog/plantuml-swagger/</id>
    <published>2018-09-15T22:00:00.000Z</published>
    <updated>2020-09-01T20:36:49.222Z</updated>
    
    
    <summary type="html">&lt;p&gt;It&amp;#8217;s great to have &lt;a href=&quot;/asciidoc-swagger/&quot;&gt;Asciidoc labels like swagger-ui&lt;/a&gt; in the documentation, but would it be possible to extend this even further?
In asciidoc documentation I also use &lt;a href=&quot;http://plantuml.com/&quot;&gt;Plantuml&lt;/a&gt; diagrams, e.g. to illustrate the sequence of interaction between microservices.
Is it possible to label those interactions like swagger-ui, just as I now can in asciidoc?&lt;/p&gt;</summary>
    
    
    
    <category term="Documentation" scheme="http://thoughts.tostring.blog/category/Documentation/"/>
    
    
    <category term="asciidoc" scheme="http://thoughts.tostring.blog/tags/asciidoc/"/>
    
    <category term="plantuml" scheme="http://thoughts.tostring.blog/tags/plantuml/"/>
    
    <category term="swagger-ui" scheme="http://thoughts.tostring.blog/tags/swagger-ui/"/>
    
  </entry>
  
  <entry>
    <title>Asciidoc labels like swagger-ui</title>
    <link href="http://thoughts.tostring.blog/asciidoc-swagger/"/>
    <id>http://thoughts.tostring.blog/asciidoc-swagger/</id>
    <published>2018-09-13T22:00:00.000Z</published>
    <updated>2020-09-01T20:36:49.222Z</updated>
    
    
    <summary type="html">&lt;p&gt;If you&amp;#8217;re building a rest api with spring-boot and want to document the api, you have two good options to do this; &lt;a href=&quot;http://springfox.github.io/springfox/&quot;&gt;Springfox&lt;/a&gt;, or &lt;a href=&quot;https://spring.io/projects/spring-restdocs&quot;&gt;Spring REST Docs&lt;/a&gt;.
Springfox creates (interactive) documentation through a swagger-ui to use by a developer, Spring REST Docs creates documentation via asciidoc.
And what&amp;#8217;s best is that you can simply combine the two in a project.&lt;/p&gt;</summary>
    
    
    
    <category term="Documentation" scheme="http://thoughts.tostring.blog/category/Documentation/"/>
    
    
    <category term="asciidoc" scheme="http://thoughts.tostring.blog/tags/asciidoc/"/>
    
    <category term="swagger-ui" scheme="http://thoughts.tostring.blog/tags/swagger-ui/"/>
    
  </entry>
  
  <entry>
    <title>Combining Spock 1.2 and Junit 5 tests</title>
    <link href="http://thoughts.tostring.blog/spock-jupiter/"/>
    <id>http://thoughts.tostring.blog/spock-jupiter/</id>
    <published>2018-09-05T22:00:00.000Z</published>
    <updated>2018-09-30T22:00:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Great projects keep moving forward. &lt;a href=&quot;https://junit.org/junit5/&quot;&gt;JUnit5&lt;/a&gt; is available since september 2017 and &lt;a href=&quot;http://spockframework.org&quot;&gt;Spock&lt;/a&gt; 1.2 was completed in september 2018.
Since Spock is based on junit4, I wondered what it would take to use Spock 1.2 together with JUnit5.&lt;/p&gt;</summary>
    
    
    
    <category term="Programming" scheme="http://thoughts.tostring.blog/category/Programming/"/>
    
    
    <category term="junit" scheme="http://thoughts.tostring.blog/tags/junit/"/>
    
    <category term="spock" scheme="http://thoughts.tostring.blog/tags/spock/"/>
    
    <category term="gradle" scheme="http://thoughts.tostring.blog/tags/gradle/"/>
    
  </entry>
  
</feed>
